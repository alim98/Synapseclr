<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Animated GIFs at {method_name} Coordinates</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1800px; /* Increased from 1200px */
            margin: 0 auto;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
            border-radius: 8px;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .plot-container {
            position: relative;
            margin: 20px auto;
            border: 1px solid #ddd;
            background-color: #fff;
            overflow: hidden;
            width: 1600px; /* Increased from 1000px */
            height: 1200px; /* Increased from 800px */
        }
        .point {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer; /* Add cursor pointer for points */
        }
        /* Add tooltip style for points */
        .point:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
        }
        .gif-container {
            position: absolute;
            border: 2px solid #333;
            background-color: white;
            border-radius: 4px;
            overflow: hidden;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            cursor: pointer; /* Show pointer cursor to indicate clickability */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .gif-container:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border-color: #4CAF50;
        }
        .gif-container::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.7);
            color: white;
            font-size: 1px;
            padding: 2px 4px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .gif-container:hover::after {
            opacity: 0.5;
        }
        .gif-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .controls {
            margin-top: 10px;
            text-align: center;
            padding: 15px;
            background-color: #f8f8f8;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls button {
            padding: 8px 15px;
            margin: 0 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .controls button:hover {
            background-color: #45a049;
        }
        .gif-size-slider {
            width: 200px;
            margin: 0 10px;
            vertical-align: middle;
        }
        .control-group {
            display: inline-block;
            margin: 0 15px;
            vertical-align: middle;
        }
        .control-label {
            font-weight: bold;
            margin-right: 10px;
        }
        .dragging {
            opacity: 0.8;
            z-index: 1000;
        }
        .cluster-filter {
            margin-top: 10px;
            text-align: center;
        }
        .cluster-checkbox {
            margin-right: 5px;
        }
        .cluster-label {
            margin-right: 15px;
            user-select: none;
        }
        #debug-message {
            padding: 10px;
            margin: 10px 0;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .frame-slider {
            width: 300px;
            margin: 0 10px;
            vertical-align: middle;
        }  
        .frame-control {
            margin-top: 10px;
            padding: 8px;
            background-color: #e8f7e8;
            border-radius: 4px;
            border: 1px solid #4CAF50;
        }
        /* Color scheme switch button */
        .color-scheme-toggle {
            margin-top: 10px;
            text-align: center;
            padding: 8px;
            background-color: #e8f5ff;
            border-radius: 4px;
            border: 1px solid #0078d7;
        }
    </style>
    <script>
        // Track whether GIFs are visible
        let gifsVisible = true;

        // Function to generate WebKnossos URL based on central coordinates and bbox number
        function generateWebknossosUrl(centralCoordX, centralCoordY, centralCoordZ, bboxName) {
            // Extract bbox number from bbox name (e.g., "bbox1" -> 1)
            const bboxNum = parseInt(bboxName.replace('bbox', ''));
            
            if (isNaN(bboxNum)) {
                console.error("Invalid bbox name format:", bboxName);
                return null;
            }
            
            let x1, y1, z1;
            
            // Calculate bbox coordinates based on central coordinates (adapted from WebknossosUrl.py)
            switch(bboxNum) {
                case 1:
                    x1 = 14219 - 100 + centralCoordX;
                    y1 = 10792 - 100 + centralCoordY;
                    z1 = 15134 - 100 + centralCoordZ;
                    break;
                case 2:
                    x1 = 18544 + centralCoordX;
                    y1 = 5409 + centralCoordY;
                    z1 = 4374 + centralCoordZ;
                    break;
                case 3:
                    x1 = 14783 - 100 + centralCoordX;
                    y1 = 3707 - 100 + centralCoordY;
                    z1 = 4316 - 100 + centralCoordZ;
                    break;
                case 4:
                    x1 = 15813 - 100 + centralCoordX;
                    y1 = 7009 - 100 + centralCoordY;
                    z1 = 10408 - 100 + centralCoordZ;
                    break;
                case 5:
                    x1 = 1782 - 100 + centralCoordX;
                    y1 = 8962 - 100 + centralCoordY;
                    z1 = 8309 - 100 + centralCoordZ;
                    break;
                case 6:
                    x1 = 16700 - 100 + centralCoordX;
                    y1 = 11200 - 100 + centralCoordY;
                    z1 = 15573 - 100 + centralCoordZ;
                    break;
                case 7:
                    x1 = 12340 + centralCoordX;
                    y1 = 9416 + centralCoordY;
                    z1 = 16439 + centralCoordZ;
                    break;
                default:
                    console.error("Unknown bbox number:", bboxNum);
                    return null;
            }
            
            // Generate the final URL
            return `https://webknossos.brain.mpg.de/annotations/67bcfa0301000006202da79c#${x1},${y1},${z1},0,0.905,1506`;
        }
    </script>
</head>
<body>
    <div class="container">
        <h1>{method_name} Visualization with Animated GIFs</h1>
        
        <div id="debug-message"></div>
        
        <div class="controls">
            <div class="control-group">
                <button id="toggle-gifs">Hide GIFs</button>
            </div>
            
            <div class="control-group">
                <span class="control-label">GIF Size:</span>
                <input type="range" min="20" max="200" value="50" id="gif-size-slider" class="gif-size-slider">
                <span id="size-value">50px</span>
                <button id="resize-gifs">Apply Size</button>
            </div>
            
            <div class="control-group">
                <span class="control-label">Number of GIFs:</span>
                <input type="range" min="1" max="{len(samples_with_gifs)}" value="{len(samples_with_gifs)}" id="num-gifs-slider" class="gif-size-slider">
                <span id="num-gifs-value">{len(samples_with_gifs)}</span>
                <button id="apply-num-gifs">Apply</button>
            </div>
            
            <div class="control-group">
                <button id="reset-positions">Reset Positions</button>
            </div>
            
            <div class="control-group frame-control">
                <span class="control-label">Frame Control:</span>
                <input type="range" min="0" max="50" value="0" id="frame-slider" class="frame-slider">
                <span id="frame-value">0</span>
                <button id="play-pause">Play/Pause</button>
                <button id="show-max-cleft">Show Max Cleft Slices</button>
            </div>
        </div>
        
        <div class="color-scheme-toggle">
            <span class="control-label">Color Scheme:</span>
            <button id="toggle-color-scheme">Toggle Colors (Current: Cluster)</button>
        </div>
        
        <div class="cluster-filter" id="cluster-filter">
            <span class="control-label">Filter by Cluster:</span>
            <!-- Cluster checkboxes will be added here by JavaScript -->
        </div>
        
        <div class="plot-container" id="plot">
            <!-- Background points will be added here -->
            <!-- GIFs will be added here -->
        </div>
    </div>
    
    <script>
        // Initialize debug element
        const debugMessage = document.getElementById('debug-message');
        function log(message) {
            debugMessage.innerHTML += message + '<br>';
            console.log(message);
        }
        
        // Segmentation type from configuration
        const segmentationType = {segmentation_type};
        console.log(`Segmentation type: ${segmentationType}`);
        
        // log("Script started");
        
        // Define the UMAP bounds
        const xMin = {x_min};
        const xMax = {x_max};
        const yMin = {y_min};
        const yMax = {y_max};
        
        // log(`Coordinate bounds: X: ${xMin} to ${xMax}, Y: ${yMin} to ${yMax}`);
        
        // Function to map UMAP coordinates to plot coordinates
        function mapToPlot(x, y, width, height) {
            const plotX = ((x - xMin) / (xMax - xMin)) * width;
            // Invert y-axis (UMAP coordinates increase upward, plot coordinates increase downward)
            const plotY = height - ((y - yMin) / (yMax - yMin)) * height;
            return [plotX, plotY];
        }
        
        // Get the plot container
        const plot = document.getElementById('plot');
        const plotWidth = plot.clientWidth;
        const plotHeight = plot.clientHeight;
        
        // log(`Plot dimensions: ${plotWidth}x${plotHeight}`);
        
        // Store original positions of GIFs for reset functionality
        let originalPositions = {};
        try {
            originalPositions = {originalPositions};
            // log(`Loaded original positions data with ${Object.keys(originalPositions).length} items`);
        } catch (e) {
            // log(`Error loading original positions: ${e.message}`);
        }
        
        // Store all GIF data with cluster information
        const allGifData = [];
        
        // Store frames data for all GIFs
        const allFramesData = {};
        try {
            // Parse frames data string to JavaScript object
            const framesStr = `{frames_content}`;
            // log(`Loading frames data: ${framesStr.substring(0, 100)}...`);
            
            // Check if we have valid JSON
            if (framesStr && framesStr !== "{}" && framesStr.length > 2) {
                const framesData = JSON.parse(framesStr);
                Object.assign(allFramesData, framesData);
                // log(`Loaded frames data for ${Object.keys(allFramesData).length} GIFs`);
            } else {
                // log("No frames data available");
            }
        } catch(e) {
            // log(`Error loading frames data: ${e.message}`);
        }
        
        // Variable to track play/pause state
        let isPlaying = false;
        let animationInterval = null;
        let currentFrame = 0;
        
        // Function to update the frame display for all GIFs
        function updateFrameDisplay(frameIndex) {
            // Update all visible gif containers
            document.querySelectorAll('.gif-container.has-frames').forEach(container => {
                const id = container.dataset.id;
                if (id && allFramesData[id] && allFramesData[id].length > 0) {
                    // Make sure we don't exceed the frame count for this GIF
                    const actualFrame = Math.min(frameIndex, allFramesData[id].length - 1);
                    const frameImg = container.querySelector('img');
                    if (frameImg) {
                        frameImg.src = `data:image/png;base64,${allFramesData[id][actualFrame]}`;
                    }
                }
            });
            
            // Update the frame value display
            document.getElementById('frame-value').textContent = frameIndex;
        }
        
        // Function to show max cleft slices for each GIF
        function showMaxCleftSlices() {
            pauseFrames(); // Stop any animation
            
            console.log("Show Max Cleft Slices button clicked");
            console.log("allGifData:", allGifData);
            
            // Count how many GIFs have max_slices data
            let gifsWithMaxSlices = 0;
            allGifData.forEach(gif => {
                if (gif.max_slices) {
                    gifsWithMaxSlices++;
                    console.log(`GIF ${gif.id} has max_slices:`, gif.max_slices);
                }
            });
            console.log(`Found ${gifsWithMaxSlices} GIFs with max_slices data`);
            
            // Update all visible gif containers
            const containers = document.querySelectorAll('.gif-container.has-frames');
            console.log(`Found ${containers.length} GIF containers with frames`);
            
            containers.forEach(container => {
                const id = container.dataset.id;
                console.log(`Processing container with ID: ${id}`);
                
                // Find the gif data with matching ID
                const gifData = allGifData.find(gif => gif.id.toString() === id);
                
                if (gifData) {
                    console.log(`Found matching gifData for ID ${id}`);
                    console.log(`gifData.max_slices:`, gifData.max_slices);
                    
                    if (gifData.max_slices) {
                        // Use max_z_slice as the default best slice to show
                        const sliceIndex = gifData.max_slices.max_z_slice;
                        console.log(`max_z_slice for GIF ${id}: ${sliceIndex}`);
                        
                        if (allFramesData[id] && allFramesData[id].length > 0) {
                            console.log(`Found frames data for GIF ${id}, number of frames: ${allFramesData[id].length}`);
                            
                            // Make sure we don't exceed the frame count for this GIF
                            const actualFrame = Math.min(sliceIndex, allFramesData[id].length - 1);
                            
                            // Update display to show the max cleft slice
                            const frameImg = container.querySelector('img');
                            if (frameImg) {
                                console.log(`Updating GIF ${id} to show frame ${actualFrame}`);
                                frameImg.src = `data:image/png;base64,${allFramesData[id][actualFrame]}`;
                                
                                // Update the frame slider to reflect this position
                                const frameSlider = document.getElementById('frame-slider');
                                if (frameSlider) {
                                    frameSlider.value = actualFrame;
                                    document.getElementById('frame-value').textContent = actualFrame;
                                }
                                
                                console.log(`Updated GIF ${id} to show max cleft slice at frame ${actualFrame}`);
                            } else {
                                console.log(`No img element found in container for GIF ${id}`);
                            }
                        } else {
                            console.log(`No frames data for GIF ${id}`);
                        }
                    } else {
                        console.log(`GIF ${id} has no max_slices data`);
                    }
                } else {
                    console.log(`No matching gifData found for ID ${id}`);
                }
            });
        }
        
        // Function to handle playing animation
        function playFrames() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            
            animationInterval = setInterval(() => {
                // Get the max frame count among all GIFs
                let maxFrames = 80; // Default value for most segmentation types
                
                // Special case: If segmentation type is 13, limit to 25 frames
                if (segmentationType === 13) {
                    console.log("Animation: Using 25 frames for segmentation type 13");
                    maxFrames = 25;
                } 
                // For all other segmentation types, use the default 80 frames
                // or calculate based on actual frame data if it exceeds 80
                else {
                    Object.values(allFramesData).forEach(frames => {
                        if (frames && frames.length > maxFrames) {
                            maxFrames = frames.length;
                        }
                    });
                }
                
                console.log(`Setting max frames to: ${maxFrames}`);
                
                // Update frame slider max value
                const frameSlider = document.getElementById('frame-slider');
                if (frameSlider) {
                    frameSlider.max = maxFrames - 1;
                
                    // Increment current frame and loop if needed
                    currentFrame = (currentFrame + 1) % maxFrames;
                
                    // Update frame slider position
                    frameSlider.value = currentFrame;
                }
                
                // Update all GIFs to show this frame
                updateFrameDisplay(currentFrame);
            }, 100); // 10 FPS
        }
        
        // Function to stop playing animation
        function pauseFrames() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }
        
        // Add background points for all samples
        function addBackgroundPoints() {
            // log("Adding background points...");
            
            // Samples from features_df
            let samples = [];
            try {
                samples = [
                    {points_content}
                ];
                // log(`Found ${samples.length} background points to add`);
            } catch (e) {
                // log(`Error loading background points: ${e.message}`);
                return;
            }
            
            // Store samples globally for later recoloring
            window.allSamples = samples;
            
            // Add points to the plot
            addPointsWithCurrentColorScheme();
        }
        
        // Current color scheme: 'cluster' or 'bbox'
        let currentColorScheme = 'cluster';
        
        // Function to add points with the current color scheme
        function addPointsWithCurrentColorScheme() {
            // Clear existing points
            document.querySelectorAll('.point').forEach(point => point.remove());
            
            let pointsAdded = 0;
            window.allSamples.forEach(sample => {
                try {
                    const [plotX, plotY] = mapToPlot(sample.x, sample.y, plotWidth, plotHeight);
                    
                    const pointElem = document.createElement('div');
                    pointElem.className = 'point';
                    pointElem.style.left = `${plotX}px`;
                    pointElem.style.top = `${plotY}px`;
                    
                    // Set color based on current color scheme
                    if (currentColorScheme === 'bbox') {
                        pointElem.style.backgroundColor = sample.bbox_color || 'rgb(100, 100, 100)';
                    } else {
                        pointElem.style.backgroundColor = sample.color || 'rgb(100, 100, 100)';
                    }
                    
                    // Add tooltip data for hovering
                    pointElem.setAttribute('data-tooltip', ` ${sample.bbox_name}, ${sample.var1}`);
                    
                    // Make points with GIFs larger
                    if (sample.hasGif) {
                        pointElem.style.width = '10px';
                        pointElem.style.height = '10px';
                        pointElem.style.border = '2px solid black';
                        pointElem.style.zIndex = '5';
                    }
                    
                    plot.appendChild(pointElem);
                    pointsAdded++;
                } catch (e) {
                    log(`Error adding point: ${e.message}`);
                }
            });
        }
        
        // Function to add GIFs
        function addGifs() {
            try {
                console.log("Starting addGifs function...");
                
                // Debug the gifs_content structure
                const gifsContentStr = `{gifs_content}`;
                console.log("Raw GIFs content string length:", gifsContentStr.length);
                console.log("GIFs content sample:", gifsContentStr.substring(0, 200) + "...");
                
                // Add each GIF at its position on the plot
                const gifs = [
                    {gifs_content}
                ];
                
                console.log(`Found ${gifs.length} GIFs to add. First GIF:`, gifs.length > 0 ? gifs[0] : "No GIFs");
                
                // Store the GIF data for later reference
                gifs.forEach(gif => {
                    // Parse max_slices data if it exists and is a string
                    if (gif.max_slices) {
                        console.log(`Found max_slices for GIF ${gif.id}:`, gif.max_slices);
                        if (typeof gif.max_slices === 'string' && gif.max_slices !== 'null') {
                            try {
                                console.log(`Parsing max_slices string for GIF ${gif.id}: ${gif.max_slices}`);
                                gif.max_slices = JSON.parse(gif.max_slices);
                                console.log(`Successfully parsed max_slices for GIF ${gif.id}:`, gif.max_slices);
                            } catch (e) {
                                console.error(`Error parsing max_slices for GIF ${gif.id}: ${e}`);
                                gif.max_slices = null;
                            }
                        } else if (gif.max_slices === 'null' || gif.max_slices === null) {
                            console.log(`GIF ${gif.id} has null max_slices`);
                            gif.max_slices = null;
                        } else {
                            console.log(`GIF ${gif.id} has max_slices that is not a string:`, typeof gif.max_slices);
                        }
                    } else {
                        console.log(`No max_slices found for GIF ${gif.id}`);
                    }
                    
                    allGifData.push(gif);
                });
                
                // Tracking placed rectangles to prevent overlap
                const placedRectangles = [];
                const gifSize = 50; // Default size
                
                // Initialize container for tracking all GIF containers
                window.gifContainers = [];
                
                // Add ALL GIFs (not just the first 20)
                console.log(`Adding all ${gifs.length} GIFs to the plot...`);
                let addedCount = 0;
                let skippedCount = 0;
                
                for (let i = 0; i < gifs.length; i++) {
                    const container = addGifToPlot(gifs[i], i, placedRectangles, gifSize);
                    if (container) {
                        addedCount++;
                        if (addedCount % 10 === 0) {
                            console.log(`Progress: Added ${addedCount} GIFs so far...`);
                        }
                    } else {
                        skippedCount++;
                    }
                }
                
                console.log(`Successfully added ${addedCount} GIFs, skipped ${skippedCount} due to positioning issues`);
                console.log(`Total GIF containers: ${window.gifContainers.length}`);
                
                // Make sure the toggle button has the correct initial state
                const toggleButton = document.getElementById('toggle-gifs');
                toggleButton.textContent = 'Hide GIFs';
                
                // Create cluster filters after adding GIFs
                createClusterFilter();
            } catch (e) {
                log(`Error adding GIFs: ${e.message}`);
                console.error("Stack trace:", e.stack);
            }
        }
        
        // Function to add a single GIF to the plot
        function addGifToPlot(sample, index, placedRectangles, gifSize) {
            try {
                const [plotX, plotY] = mapToPlot(sample.x, sample.y, plotWidth, plotHeight);
                
                // Use original position if available
                let posX = plotX;
                let posY = plotY;
                
                // Try to get original position that was pre-calculated to avoid overlap
                if (originalPositions && originalPositions[sample.id]) {
                    console.log(`Using pre-calculated non-overlapping position for GIF ${sample.id}`);
                    posX = originalPositions[sample.id].x;
                    posY = originalPositions[sample.id].y;
                    
                    // Create rectangle for tracking existing positions
                    const halfSize = gifSize / 2;
                    const rect = {
                        left: posX - halfSize,
                        right: posX + halfSize,
                        top: posY - halfSize,
                        bottom: posY + halfSize
                    };
                    
                    // Add to tracking
                    placedRectangles.push(rect);
                } else {
                    // Find non-overlapping position if no original position
                    console.log(`Finding non-overlapping position for GIF ${sample.id}`);
                    const position = findNonOverlappingPosition(plotX, plotY, placedRectangles, gifSize);
                    
                    // Skip if no valid position found
                    if (!position) {
                        console.log(`Skipping GIF ${sample.id} - couldn't find non-overlapping position`);
                        return null;
                    }
                    
                    posX = position.x;
                    posY = position.y;
                    
                    // Add rectangle to tracking
                    placedRectangles.push(position.rect);
                    console.log(`Found non-overlapping position for GIF ${sample.id} at (${posX}, ${posY})`);
                }
                
                // Create GIF container
                const gifContainer = document.createElement('div');
                gifContainer.className = 'gif-container';
                if (sample.hasFrames) {
                    gifContainer.classList.add('has-frames');
                }
                gifContainer.id = `gif-${sample.id}`;
                gifContainer.dataset.id = sample.id;
                gifContainer.dataset.index = index;
                gifContainer.dataset.cluster = sample.cluster;
                gifContainer.dataset.bbox = sample.bbox;
                
                // Set position and size
                gifContainer.style.left = `${posX}px`;
                gifContainer.style.top = `${posY}px`;
                gifContainer.style.width = `${gifSize}px`;
                gifContainer.style.height = `${gifSize}px`;
                gifContainer.style.display = 'block'; // Make sure GIFs are visible by default
                
                // Add coordinates for WebKnossos
                gifContainer.dataset.centralCoord1 = sample.central_coord_1 || 0;
                gifContainer.dataset.centralCoord2 = sample.central_coord_2 || 0;
                gifContainer.dataset.centralCoord3 = sample.central_coord_3 || 0;
                
                // Add max slices data if available
                if (sample.max_slices) {
                    gifContainer.dataset.maxSlices = JSON.stringify(sample.max_slices);
                }
                
                // Create image
                const gifImg = document.createElement('img');
                gifImg.src = `data:image/gif;base64,${sample.gifData}`;
                gifImg.alt = `Sample ${sample.id}`;
                
                // Add click handler for WebKnossos
                gifContainer.addEventListener('click', (e) => {
                    // Skip if was dragging
                    if (gifContainer.dataset.wasDragging === 'true') {
                        return;
                    }
                    
                    // Generate URL
                    const centralCoordX = parseInt(gifContainer.dataset.centralCoord1);
                    const centralCoordY = parseInt(gifContainer.dataset.centralCoord2);
                    const centralCoordZ = parseInt(gifContainer.dataset.centralCoord3);
                    const bboxName = gifContainer.dataset.bbox;
                    
                    if (centralCoordX && centralCoordY && centralCoordZ && bboxName) {
                        const url = generateWebknossosUrl(centralCoordX, centralCoordY, centralCoordZ, bboxName);
                        if (url) {
                            gifContainer.style.borderColor = '#4CAF50';
                            setTimeout(() => {
                                window.open(url, '_blank');
                            }, 150);
                        }
                    }
                });
                
                // Add image to container
                gifContainer.appendChild(gifImg);
                
                // Make draggable
                makeDraggable(gifContainer);
                
                // Add to plot
                plot.appendChild(gifContainer);
                
                // Add to global tracking
                window.gifContainers.push(gifContainer);
                
                return gifContainer;
            } catch (e) {
                console.error(`Error adding GIF ${sample.id}: ${e}`);
                return null;
            }
        }
        
        // Function to check if two rectangles overlap
        function doRectanglesOverlap(rect1, rect2) {
            return !(rect1.right < rect2.left || 
                    rect1.left > rect2.right || 
                    rect1.bottom < rect2.top || 
                    rect1.top > rect2.bottom);
        }
        
        // Function to find a non-overlapping position
        function findNonOverlappingPosition(baseX, baseY, existingRects, gifSize) {
            // Check if the original position works
            const halfSize = gifSize / 2;
            const rect = {
                left: baseX - halfSize,
                right: baseX + halfSize,
                top: baseY - halfSize,
                bottom: baseY + halfSize
            };
            
            // Check if original position has no overlap
            let hasOverlap = false;
            let overlapRect = null;
            
            for (const existingRect of existingRects) {
                if (doRectanglesOverlap(rect, existingRect)) {
                    hasOverlap = true;
                    overlapRect = existingRect;
                    break;
                }
            }
            
            // If no overlap, use original position
            if (!hasOverlap) {
                return { x: baseX, y: baseY, rect: rect };
            }
            
            // Calculate the minimum shift needed in each direction to avoid overlap
            if (overlapRect) {
                // Calculate overlap amounts in each direction
                const overlapRight = rect.right - overlapRect.left;
                const overlapLeft = overlapRect.right - rect.left;
                const overlapBottom = rect.bottom - overlapRect.top;
                const overlapTop = overlapRect.bottom - rect.top;
                
                // Find the smallest shift needed
                const shifts = [
                    { axis: 'x', amount: overlapRight, direction: 1 },  // shift right
                    { axis: 'x', amount: -overlapLeft, direction: -1 }, // shift left
                    { axis: 'y', amount: overlapBottom, direction: 1 },  // shift down
                    { axis: 'y', amount: -overlapTop, direction: -1 }   // shift up
                ];
                
                // Sort by absolute amount to find smallest shift
                shifts.sort((a, b) => Math.abs(a.amount) - Math.abs(b.amount));
                
                // Maximum distance to shift
                const shiftLimit = 100; // Increased from 50 to 100 for more positioning options
                
                // Try each shift until we find one that works
                for (const shift of shifts) {
                    // Skip if shift is too large
                    if (Math.abs(shift.amount) > shiftLimit) {
                        continue;
                    }
                    
                    let shiftedX = baseX;
                    let shiftedY = baseY;
                    
                    if (shift.axis === 'x') {
                        shiftedX += shift.amount;
                    } else {
                        shiftedY += shift.amount;
                    }
                    
                    // Skip if this would move the GIF out of bounds
                    if (shiftedX - halfSize < 0 || shiftedX + halfSize > plotWidth ||
                        shiftedY - halfSize < 0 || shiftedY + halfSize > plotHeight) {
                        continue;
                    }
                    
                    // Check if this position works with all existing rectangles
                    const shiftedRect = {
                        left: shiftedX - halfSize,
                        right: shiftedX + halfSize,
                        top: shiftedY - halfSize,
                        bottom: shiftedY + halfSize
                    };
                    
                    let shiftedOverlap = false;
                    for (const existingRect of existingRects) {
                        if (doRectanglesOverlap(shiftedRect, existingRect)) {
                            shiftedOverlap = true;
                            break;
                        }
                    }
                    
                    if (!shiftedOverlap) {
                        return { x: shiftedX, y: shiftedY, rect: shiftedRect };
                    }
                }
            }
            
            // If the simple shifts didn't work, try a more general approach
            // Try cardinal and diagonal directions with increasing distances
            const directions = [
                { x: 1, y: 0 },  // right
                { x: 0, y: 1 },  // down
                { x: -1, y: 0 }, // left
                { x: 0, y: -1 }, // up
                { x: 1, y: 1 },  // down-right
                { x: 1, y: -1 }, // up-right
                { x: -1, y: 1 }, // down-left
                { x: -1, y: -1 } // up-left
            ];
            
            // Try increasing distances with 1px increments (smaller steps)
            const maxDistance = 100; // Increased from 50 to 100
            for (let distance = 1; distance <= maxDistance; distance += 1) {
                for (const dir of directions) {
                    const shiftedX = baseX + (dir.x * distance);
                    const shiftedY = baseY + (dir.y * distance);
                    
                    // Skip if this would move the GIF out of bounds
                    if (shiftedX - halfSize < 0 || shiftedX + halfSize > plotWidth ||
                        shiftedY - halfSize < 0 || shiftedY + halfSize > plotHeight) {
                        continue;
                    }
                    
                    // Check this position
                    const shiftedRect = {
                        left: shiftedX - halfSize,
                        right: shiftedX + halfSize,
                        top: shiftedY - halfSize,
                        bottom: shiftedY + halfSize
                    };
                    
                    let shiftedOverlap = false;
                    for (const existingRect of existingRects) {
                        if (doRectanglesOverlap(shiftedRect, existingRect)) {
                            shiftedOverlap = true;
                            break;
                        }
                    }
                    
                    if (!shiftedOverlap) {
                        return { x: shiftedX, y: shiftedY, rect: shiftedRect };
                    }
                }
            }
            
            // Try with slightly smaller GIF size as a last resort (80% of original size)
            const reducedHalfSize = halfSize * 0.8;
            for (let distance = 1; distance <= maxDistance; distance += 2) {
                for (const dir of directions) {
                    const shiftedX = baseX + (dir.x * distance);
                    const shiftedY = baseY + (dir.y * distance);
                    
                    // Check this position with reduced size
                    const shiftedRect = {
                        left: shiftedX - reducedHalfSize,
                        right: shiftedX + reducedHalfSize,
                        top: shiftedY - reducedHalfSize,
                        bottom: shiftedY + reducedHalfSize
                    };
                    
                    let shiftedOverlap = false;
                    for (const existingRect of existingRects) {
                        if (doRectanglesOverlap(shiftedRect, existingRect)) {
                            shiftedOverlap = true;
                            break;
                        }
                    }
                    
                    if (!shiftedOverlap) {
                        // Return with original half size for consistent appearance, 
                        // but the checking was done with reduced size
                        const visualRect = {
                            left: shiftedX - halfSize,
                            right: shiftedX + halfSize,
                            top: shiftedY - halfSize,
                            bottom: shiftedY + halfSize
                        };
                        
                        // But store the actual non-overlapping rectangle
                        return { x: shiftedX, y: shiftedY, rect: shiftedRect };
                    }
                }
            }
            
            // No non-overlapping position found
            return null;
        }
        
        // Create cluster filter checkboxes
        function createClusterFilter() {
            updateFilterSection();
        }
        
        // Function to update the filter section based on current color scheme
        function updateFilterSection() {
            const clusterFilter = document.getElementById('cluster-filter');
            
            // Clear existing content
            clusterFilter.innerHTML = '';
            
            if (currentColorScheme === 'cluster') {
                // Add cluster filter title
                const title = document.createElement('span');
                title.className = 'control-label';
                title.textContent = 'Filter by Cluster:';
                clusterFilter.appendChild(title);
                
                // Get unique clusters
                const clusters = new Set();
                allGifData.forEach(sample => {
                    if (sample['cluster'] !== 'N/A' && sample['cluster'] !== 'unknown') {
                        clusters.add(sample['cluster']);
                    }
                });
                
                // Create a checkbox for each cluster
                clusters.forEach(cluster => {
                    const label = document.createElement('label');
                    label.className = 'cluster-label';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'cluster-checkbox';
                    checkbox.value = cluster;
                    checkbox.checked = true;
                    checkbox.id = `cluster-${cluster}`;
                    
                    checkbox.addEventListener('change', updateVisibleGifs);
                    
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(`Cluster ${cluster}`));
                    
                    clusterFilter.appendChild(label);
                });
            } else {
                // Add bbox filter title
                const title = document.createElement('span');
                title.className = 'control-label';
                title.textContent = 'Filter by Bbox:';
                clusterFilter.appendChild(title);
                
                // Get unique bboxes
                const bboxes = new Set();
                allGifData.forEach(sample => {
                    if (sample['bbox'] && sample['bbox'] !== 'unknown') {
                        bboxes.add(sample['bbox']);
                    }
                });
                
                // Create a checkbox for each bbox
                bboxes.forEach(bbox => {
                    const label = document.createElement('label');
                    label.className = 'cluster-label';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'bbox-checkbox';
                    checkbox.value = bbox;
                    checkbox.checked = true;
                    checkbox.id = `bbox-${bbox}`;
                    
                    checkbox.addEventListener('change', updateVisibleGifs);
                    
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(`${bbox}`));
                    
                    clusterFilter.appendChild(label);
                });
            }
            
            // Add "Select All" and "Deselect All" buttons
            clusterFilter.appendChild(document.createElement('br'));
            
            const selectAllBtn = document.createElement('button');
            selectAllBtn.textContent = 'Select All';
            selectAllBtn.addEventListener('click', () => {
                if (currentColorScheme === 'cluster') {
                    document.querySelectorAll('.cluster-checkbox').forEach(cb => {
                        cb.checked = true;
                    });
                } else {
                    document.querySelectorAll('.bbox-checkbox').forEach(cb => {
                        cb.checked = true;
                    });
                }
                updateVisibleGifs();
            });
            
            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.textContent = 'Deselect All';
            deselectAllBtn.addEventListener('click', () => {
                if (currentColorScheme === 'cluster') {
                    document.querySelectorAll('.cluster-checkbox').forEach(cb => {
                        cb.checked = false;
                    });
                } else {
                    document.querySelectorAll('.bbox-checkbox').forEach(cb => {
                        cb.checked = false;
                    });
                }
                updateVisibleGifs();
            });
            
            clusterFilter.appendChild(selectAllBtn);
            clusterFilter.appendChild(deselectAllBtn);
        }
        
        // Update visible GIFs based on filters
        function updateVisibleGifs() {
            console.log("Updating visible GIFs...");
            
            // Get selected filters based on current color scheme
            const selectedFilters = [];
            if (currentColorScheme === 'cluster') {
                document.querySelectorAll('.cluster-checkbox:checked').forEach(cb => {
                    selectedFilters.push(cb.value);
                });
                console.log("Selected clusters:", selectedFilters);
            } else {
                document.querySelectorAll('.bbox-checkbox:checked').forEach(cb => {
                    selectedFilters.push(cb.value);
                });
                console.log("Selected bboxes:", selectedFilters);
            }
            
            // Get max number of GIFs to show
            const maxGifs = parseInt(document.getElementById('num-gifs-slider').value);
            console.log("Max GIFs to show:", maxGifs);
            
            // Check if no container is available yet
            if (!window.gifContainers || window.gifContainers.length === 0) {
                console.log("No GIF containers available yet");
                return;
            }
            
            // Group GIFs by filter category (cluster or bbox)
            const gifsByCategory = {};
            window.gifContainers.forEach(container => {
                const category = currentColorScheme === 'cluster' ? container.dataset.cluster : container.dataset.bbox;
                if (!gifsByCategory[category]) {
                    gifsByCategory[category] = [];
                }
                gifsByCategory[category].push(container);
            });
            
            // Calculate how many GIFs to show per selected category
            const selectedCategoryCount = selectedFilters.length;
            const gifsPerCategory = selectedCategoryCount > 0 ? Math.ceil(maxGifs / selectedCategoryCount) : 0;
            console.log(`Showing approximately ${gifsPerCategory} GIFs per selected category`);
            
            // Track how many GIFs we've shown in total and per category
            let shownCount = 0;
            const shownPerCategory = {};
            
            // First pass: Show GIFs from selected categories up to the gifsPerCategory limit
            window.gifContainers.forEach(container => {
                const category = currentColorScheme === 'cluster' ? container.dataset.cluster : container.dataset.bbox;
                
                // Initialize counter for this category if needed
                if (!shownPerCategory[category]) {
                    shownPerCategory[category] = 0;
                }
                
                // Only show if category is selected, we haven't reached the per-category limit, 
                // and we haven't reached the total limit
                const shouldShow = selectedFilters.includes(category) && 
                                  shownPerCategory[category] < gifsPerCategory &&
                                  shownCount < maxGifs && 
                                  gifsVisible;
                
                if (shouldShow) {
                    container.style.display = 'block';
                    shownCount++;
                    shownPerCategory[category]++;
                    console.log(`Showing GIF ${container.dataset.id} (${currentColorScheme}: ${category}, ${shownPerCategory[category]}/${gifsPerCategory})`);
                } else {
                    container.style.display = 'none';
                }
            });
            
            // Second pass: If we haven't shown enough GIFs, add more from categories that have extras
            if (shownCount < maxGifs && gifsVisible) {
                window.gifContainers.forEach(container => {
                    const category = currentColorScheme === 'cluster' ? container.dataset.cluster : container.dataset.bbox;
                    
                    // Skip if category not selected or GIF already visible
                    if (!selectedFilters.includes(category) || container.style.display === 'block') {
                        return;
                    }
                    
                    // Show additional GIFs from this category if we haven't reached the total limit
                    if (shownCount < maxGifs) {
                        container.style.display = 'block';
                        shownCount++;
                        shownPerCategory[category]++;
                        console.log(`Showing additional GIF ${container.dataset.id} (${currentColorScheme}: ${category})`);
                    }
                });
            }
            
            console.log(`Showing ${shownCount} total GIFs across ${selectedCategoryCount} categories`);
            
            // Update the displayed count
            document.getElementById('num-gifs-value').textContent = shownCount;
        }
        
        // Make an element draggable
        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            
            element.onmousedown = dragMouseDown;
            
            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Add dragging class
                element.classList.add('dragging');
                isDragging = false; // Reset dragging flag
                
                // Bring the element to the front
                element.style.zIndex = "1000";
                
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }
            
            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                
                // Set dragging flag when the mouse moves
                isDragging = true;
                
                // Calculate the new cursor position
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Set the element's new position
                const newTop = (element.offsetTop - pos2);
                const newLeft = (element.offsetLeft - pos1);
                
                // Constrain to plot boundaries
                const elemWidth = parseInt(element.style.width);
                const elemHeight = parseInt(element.style.height);
                
                const boundedTop = Math.max(elemHeight/2, Math.min(newTop, plotHeight - elemHeight/2));
                const boundedLeft = Math.max(elemWidth/2, Math.min(newLeft, plotWidth - elemWidth/2));
                
                element.style.top = boundedTop + "px";
                element.style.left = boundedLeft + "px";
            }
            
            function closeDragElement() {
                // Stop moving when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
                
                // If was actually dragging, add a data attribute to prevent click event
                if (isDragging) {
                    element.dataset.wasDragging = 'true';
                    setTimeout(() => {
                        delete element.dataset.wasDragging;
                    }, 100);
                }
                
                // Remove dragging class
                element.classList.remove('dragging');
                
                // Reset z-index to normal
                setTimeout(() => {
                    element.style.zIndex = "10";
                }, 200);
            }
            
            // Add a click handler to override the default click if was dragging
            element.addEventListener('click', (e) => {
                if (element.dataset.wasDragging === 'true') {
                    e.stopPropagation(); // Prevent the click event from bubbling up
                }
            }, true); // Use capture phase
        }
        
        // Initialize the visualization
        function init() {
            // Add background points
            addBackgroundPoints();
            
            // Add GIFs
            addGifs();
            
            // Set up toggle button
            const toggleButton = document.getElementById('toggle-gifs');
            
            toggleButton.addEventListener('click', () => {
                gifsVisible = !gifsVisible;
                toggleButton.textContent = gifsVisible ? 'Hide GIFs' : 'Show GIFs';
                updateVisibleGifs();
            });
            
            // Set up resize functionality
            const sizeSlider = document.getElementById('gif-size-slider');
            const sizeValue = document.getElementById('size-value');
            
            sizeSlider.addEventListener('input', () => {
                const size = sizeSlider.value;
                sizeValue.textContent = size + 'px';
            });
            
            // Set up resize button
            const resizeButton = document.getElementById('resize-gifs');
            resizeButton.addEventListener('click', () => {
                const size = sizeSlider.value;
                
                window.gifContainers.forEach(container => {
                    container.style.width = size + 'px';
                    container.style.height = size + 'px';
                });
            });
            
            // Set up number of GIFs slider
            const numGifsSlider = document.getElementById('num-gifs-slider');
            const numGifsValue = document.getElementById('num-gifs-value');
            
            numGifsSlider.addEventListener('input', () => {
                const num = numGifsSlider.value;
                numGifsValue.textContent = num;
            });
            
            // Set up apply number of GIFs button
            const applyNumGifsButton = document.getElementById('apply-num-gifs');
            applyNumGifsButton.addEventListener('click', updateVisibleGifs);
            
            // Set up reset positions button
            const resetButton = document.getElementById('reset-positions');
            resetButton.addEventListener('click', () => {
                window.gifContainers.forEach(container => {
                    const id = container.id.replace('gif-', '');
                    // Use safe property access with proper syntax
                    if (originalPositions[id]) {
                        const pos = originalPositions[id];
                        container.style.left = `${pos.x}px`;
                        container.style.top = `${pos.y}px`;
                    }
                });
            });
            
            // Setup frame slider
            const frameSlider = document.getElementById('frame-slider');
            const frameValue = document.getElementById('frame-value');
            
            // Find the maximum number of frames across all GIFs
            let maxFrames = 80; // Default value for most segmentation types
            
            // Special case: If segmentation type is 13, limit to 25 frames
            if (segmentationType === 13) {
                console.log("Animation: Using 25 frames for segmentation type 13");
                maxFrames = 25;
            } 
            // For all other segmentation types, use the default 80 frames
            // or calculate based on actual frame data if it exceeds 80
            else {
                Object.values(allFramesData).forEach(frames => {
                    if (frames && frames.length > maxFrames) {
                        maxFrames = frames.length;
                    }
                });
            }
            
            console.log(`Setting max frames to: ${maxFrames}`);
            
            // Set the slider max value
            frameSlider.max = maxFrames - 1;
            
            frameSlider.addEventListener('input', () => {
                // Update the displayed value
                currentFrame = parseInt(frameSlider.value);
                frameValue.textContent = currentFrame;
                
                // Pause any animation that's playing
                if (isPlaying) {
                    pauseFrames();
                    isPlaying = false;
                }
                
                // Update all GIFs to display the selected frame
                updateFrameDisplay(currentFrame);
            });
            
            // Setup play/pause button
            const playPauseButton = document.getElementById('play-pause');
            playPauseButton.addEventListener('click', () => {
                isPlaying = !isPlaying;
                
                if (isPlaying) {
                    playFrames();
                    playPauseButton.textContent = 'Pause';
                } else {
                    pauseFrames();
                    playPauseButton.textContent = 'Play';
                }
            });
            
            // Add event listener for the show max cleft button
            document.getElementById('show-max-cleft').addEventListener('click', showMaxCleftSlices);
            
            // Setup color scheme toggle button
            const colorToggleButton = document.getElementById('toggle-color-scheme');
            colorToggleButton.addEventListener('click', () => {
                // Toggle color scheme
                currentColorScheme = currentColorScheme === 'cluster' ? 'bbox' : 'cluster';
                
                // Update button text
                colorToggleButton.textContent = `Toggle Colors (Current: ${currentColorScheme === 'cluster' ? 'Cluster' : 'Bbox'})`;
                
                // Recolor points
                addPointsWithCurrentColorScheme();
                
                // Update filter section with new categories
                updateFilterSection();
                
                // Update visible GIFs based on new filters
                updateVisibleGifs();
            });
            
            // Initial update of visible GIFs
            updateVisibleGifs();
            
            console.log("Initialization complete. GIFs visible:", gifsVisible);
            console.log("Total GIF containers:", window.gifContainers.length);
        }
        
        // Run initialization
        window.onload = init;
    </script>
</body>
</html>
